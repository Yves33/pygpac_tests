BUGS, ISSUES and COMMENTS (python interface only)
==============================
les exemples minimaux requièrent pygame+imgui (sauf minimal_avgen).
en principe, le fichier glgpac.py reprend juste les routines du howto et ne contient pas trop de bugs

__________
0) 01_minimal_avgen.py
le fichier de .gpac/GPAC.cfg (sous linux) ne contient pas l'option -js-dirs. 
Il faudrait qu'elle soit présente et correctement renseignée, pour éviter d'avoir à la spécifier dans le programme python (on ne sait pas ou l'utilisateur a installé gpac)

__________
1) 01_minimal_avgen.py
fs.load("avgen") ne marche pas sous python (Failed to get default shared dir//Filter avgen failed to setup: Bad Parameter). 
+ je dois remplacer $GSHARE/res par un chemin absolu hardcoded dans avgen/init.js
+ une option de configuration -gshare (similaire à -js-dirs) pourrait être implémentée (ou à défaut une variable d'environnement)?

__________
1bis) 01_minimal_avgen.py
même après avoir corrigé le path dans avgen, ca ne marche toujours pas
+ je dois modifier libgpac.py:
## line 2461 - if type==GF_PROP_UINT:
## line 2461 + if type==GF_PROP_UINT or type==GF_PROP_PIXFMT:

NB: j'ai le même problème dans FromGLRGB: si j'utilise 
opid.set_prop("PixelFormat", "rgb") dans un filtre (toGLRGB),
pid.get_prop("PixelFormat") échoue dans le filtre suivant

__________
2) 02_minimal_gl_pause_resume.py
j'ai un filtre Controler (CAPS_INPUT_OUTPUT) qui de facon basique, fait:
def pause() ->send GF_FEVT_PAUSE
def resume() ->send GF_FEVT_RESUME
def process() ->if paused: return 0 // else: forward packet normally
+ si on attend trop longtemps en mode pause, le programme bug avec un avertissement "100000 consecutive process with no packet discarded or sent"
+ si le filtre est déclaré en sink avec GF_CAPS_INPUT (et pas GF_CAPS_INPUT_OUTPUT), pas de problème (mais il faut le mettre en fin de chaine)
-> est-ce que seuls les sinks purs (GF_CAPS_INPUT) sont autorisés à faire un pause/resume?
-> peut on envisager un flag à la création du filtre qui empêcherait de compter ces erreurs

__________
2bis) 02_minimal_gl_pause_resume.py
Dans ce même filtre Controler, j'ai une fonction step()
def step() -> if paused: self.paused=False;self.process();self.pause=True
+ step() marche (au moins dans une session avec une seule source), mais je ne suis pas sûr que ce soit la meilleure façon de procéder.
+ en plus, j'ai des problèmes sur mes dts qui ne sont en retard sur l'image (voir le point suivant), notamment après un seek

__________
3) 03_minimal_gl_pause_resume_seek.py
Même filtre Controler que précédemment, mais avec une méthode seek.
+ avec ffdec, les premiers packets après le seek sont ceux attendus (avec un dts correct)
+ avec nfdec, les n (6-8) premiers packets sont dans la continuité des précédents. Je suppose qu'il faudrait vider le tampon du décodeur nvdec (comment?).
__________
4) 04_minimal_gl_on_the_fly_recording.py
J'insère ffenc de façon dynamique. Ca a l'air de marcher mais:
+ lorsque je débute l'enregistrement, je ne parviens pas à enlever mon sink
+ lorsque j'arrête l'enregistrement, le fichier n'est pas écrit sur le disque avant l'appel à fs.abort(GF_FS_FLUSH_ALL) (et je souhaiterai qu'il le fût!)
+ lorsque j'arrête l'enregistrement, les premières frames suivant l'arrêt sont dispatchées à vitesse maximale 
(videos en haute resolution 5760x2880. l'encodage se fait à ~0.3x vitesse reelle sur mon poste)

__________
05) 05_minimal_gl_forward.py
j'ai adapté glpush pour faire un filtre qui crée des packets d'interface frame_ifce_gl, mais avec pck.data vide
Je pense qu'il marche car j'arrive à forwarder les packets vers vout:disp=gl (après avoir ajusté la luminosité dans le shader). Là, j'ai 2 questions:
+ vflip, vcrop, ffsws, ffenc n'acceptent pas des paquets d'interface sans data (donc avec seulement les texture ID). 
En fait, il y a très peu de filtres qui utilisent opengl (vout, avmix?, compositor?, ...). Est-ce qu'il est obligatoire pour les paquets d'interface d'avoir des data?
+ peut-on pour utiliser avmix/compositor depuis python (pour mixer différents flux, faire du picture-in-picture, etc)

___________
06) pas d'exemple
version courte: 
un filtre a 2 ipids (ou plus).
def process(self):
    for pid in ipids:
        parent_filter=pid.filter_name ## <= avilable in python api, but not necessarily unique. 
        parent_filter=pid.filter_ID   ## <= not available in current python API. could be used for pid disambiguation
        if parent_filter==xx: update_background_texture(pid)
        elif parent_filter==yy : update_foreground_texture(pid)
        elif parent_filter==zz : update_mask(pid)

version longue:
j'ai un filtre qui fait de la composition (parceque j'ai pas encore compris comment utiliser avmix/compositor!):
bg=fs.load("backgroung.mp4")
fg=fs.load("foreground.mp4")
## creates two blur filter for each input. filter name is *intentionnally* the same for  both filters
bgblur=MyBlurFilter() ## custom blur filter. filter name is "BLUR"
fgblur=MyBlurFilter() ## custom blur filter. filter name is also "BLUR", but filter.ID should be different
bgblur.set_source(bg)
fgblur.set_source(fg)
compose=myComposer()
compose.set_source(bgblur)
compose.set_source(fgblur)

+ si mes tests sont exacts, il n'y a aucune garantie que l'ordre des ipids du filtre compose doit celui dans lequel on affecte les sources (bg,fg)?
+ lorsqu'on fait une iteration sur les ipids, les pids ont un champ filter_name (nom du filtre source), mais pas filter_ID. Or 2 filtres peuvent avoir le même nom (voir le cas ci dessus) mais pas le même ID.

compose.bgid=bgblur.ID
compose.fgid=fgblur.ID
(...)
class myComposer:
    def process(self):
        for pid in ipids:
            pck=pid.get_packet()
            if pid.filter_ID==self.bgid:                   ## does not work if using pid.filter_name
                ## update background texture
            elif pid.filter_ID==self.fgid:
                ## update foreground texture
        ## having updated the textures, we can draw
        glBindTexture(GL_TEXTURE_2D,self.bgtex)
        ## render background
        glBindTexture(GL_TEXTURE_2D,self.fgtex)
        ## render foreground